1. go mod的机制
   以 完整的域名+路径 形式导入
这里的域名是 ###github.com###，是个明确的公共代码托管平台，Go 工具链默认支持这些主流的公共代码托管平台（github.com、gitlab.com、bitbucket.org 等），它知道怎么去抓源码，直接用 Git 克隆仓库。
所以这种情况下不用任何额外机制，直接去 GitHub 克隆代码。

import "go.k6.io/k6"
这个域名 go.k6.io 并不是大家熟悉的公共代码托管平台，也不是 GitHub、GitLab 这类平台。

这时候，Go 工具链不知道怎么直接去拿代码。

于是它会去请求：
https://go.k6.io/k6?go-get=1
去获取这个地址返回的 HTML meta 标签，里面会告诉它：
真实的代码托管地址在哪里（比如 GitHub）
用什么版本控制系统（git、hg等）
 
如何验证：   
          这个是302  其实等同于  curl -L https://go.k6.io/k6?go-get=1
        响应是
 curl -L https://go.k6.io/k6\?go-get\=1  重点是:go-import这句
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="go-import" content="go.k6.io/k6 git https://github.com/grafana/k6"> 
    <meta name="go-source" content="go.k6.io/k6 https://github.com/grafana/k6 https://github.com/grafana/k6/tree/master{/dir} https://github.com/grafana/k6/blob/master{/dir}/{file}#L{line}">
    <meta http-equiv="refresh" content="0; url=https://github.com/grafana/k6">
  </head>
  <body>
    Redirecting to <a href="https://github.com/grafana/k6">https://github.com/grafana/k6</a>...
  </body>
</html>
```

2   复制一个项目后要改两个地方
1. go.mod中的module要改，
2. 然后再就是整个项目中import的地方要改 
3.  go mod tidy
如何检查呢， go mod graph | grep go.k6.io/k6 


3  间接依赖中又依赖于原来的k6,

因为 Go 的 internal 是根据 import 路径来判断“是否属于模块”的。即使你替换了 module 来源，import 路径没有变，Go 仍然认为是“外部模块访问 internal 包”，
Go 的 internal 检查是基于 import path，而不是 file 实际来源
请看下面的问题
❯go mod graph | grep go.k6.io/k6
输出结果如下:
go.k6.io/k6 go.k6.io/k6@v1.0.0
github.com/grafana/xk6-dashboard@v0.7.11 go.k6.io/k6@v1.0.0
github.com/grafana/xk6-redis@v0.3.4 go.k6.io/k6@v0.51.1-0.20240606120708-bd114fdbd683
github.com/mstoykov/k6-taskqueue-lib@v0.1.3 go.k6.io/k6@v0.53.0

4 既然我已经 go mod vendor 把依赖都复制到 vendor/ 下了，那我在 go build 的时候肯定会默认用这些 vendor 下的内容么？
真相：Go 默认不会使用 vendor/ 目录！
除非你显式指定 -mod=vendor，或者设置了 export GOFLAGS=-mod=vendor
  go build -mod=vendor
否则即使你运行过 go mod vendor，Go 默认仍然使用模块缓存（比如 $GOPATH/pkg/mod）来解析依赖

5 构建过程--***那到底 Go 是怎么找到 main 函数的？***
每一个目录是一个 Go 包（一个 package）
每个目录下的 .go 文件应该有相同的 package xxx 声明
构建的时候是以目录为单位的，而不是以单个文件为单位

go build ./examples/foo
构建的是 ./examples/foo 目录下的 Go 包（不管你当前在哪）

Go 并不是在全局搜索 main 函数
它只构建你指定的「包」（也就是一个目录），然后：
如果这个包是 package main
并且有 func main()
那就会构建出一个可执行程序

如果你在没有指定参数的情况下运行：

go build
Go 会：
构建当前目录作为一个包
自动把***当前目录（不包括子目录）***下所有以 .go 结尾的源码文件（不包括测试文件）都加入编译
如果当前目录是 package main，就尝试构建可执行文




