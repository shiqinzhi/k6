1. go mod的机制
   以 完整的域名+路径 形式导入
这里的域名是 ###github.com###，是个明确的公共代码托管平台，Go 工具链默认支持这些主流的公共代码托管平台（github.com、gitlab.com、bitbucket.org 等），它知道怎么去抓源码，直接用 Git 克隆仓库。
所以这种情况下不用任何额外机制，直接去 GitHub 克隆代码。

import "go.k6.io/k6"
这个域名 go.k6.io 并不是大家熟悉的公共代码托管平台，也不是 GitHub、GitLab 这类平台。

这时候，Go 工具链不知道怎么直接去拿代码。

于是它会去请求：
https://go.k6.io/k6?go-get=1
去获取这个地址返回的 HTML meta 标签，里面会告诉它：
真实的代码托管地址在哪里（比如 GitHub）
用什么版本控制系统（git、hg等）
 
如何验证：   
          这个是302  其实等同于  curl -L https://go.k6.io/k6?go-get=1
        响应是
 curl -L https://go.k6.io/k6\?go-get\=1  重点是:go-import这句
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="go-import" content="go.k6.io/k6 git https://github.com/grafana/k6"> 
    <meta name="go-source" content="go.k6.io/k6 https://github.com/grafana/k6 https://github.com/grafana/k6/tree/master{/dir} https://github.com/grafana/k6/blob/master{/dir}/{file}#L{line}">
    <meta http-equiv="refresh" content="0; url=https://github.com/grafana/k6">
  </head>
  <body>
    Redirecting to <a href="https://github.com/grafana/k6">https://github.com/grafana/k6</a>...
  </body>
</html>
```

2   复制一个项目后要改两个地方
1. go.mod中的module要改，
2. 然后再就是整个项目中import的地方要改 
3.  go mod tidy
如何检查呢， go mod graph | grep go.k6.io/k6 


3  间接依赖中又依赖于原来的k6,

因为 Go 的 internal 是根据 import 路径来判断“是否属于模块”的。即使你替换了 module 来源，import 路径没有变，Go 仍然认为是“外部模块访问 internal 包”，
Go 的 internal 检查是基于 import path，而不是 file 实际来源
请看下面的问题
❯go mod graph | grep go.k6.io/k6
输出结果如下:
go.k6.io/k6 go.k6.io/k6@v1.0.0
github.com/grafana/xk6-dashboard@v0.7.11 go.k6.io/k6@v1.0.0
github.com/grafana/xk6-redis@v0.3.4 go.k6.io/k6@v0.51.1-0.20240606120708-bd114fdbd683
github.com/mstoykov/k6-taskqueue-lib@v0.1.3 go.k6.io/k6@v0.53.0

4 既然我已经 go mod vendor 把依赖都复制到 vendor/ 下了，那我在 go build 的时候肯定会默认用这些 vendor 下的内容么？
真相：Go 默认不会使用 vendor/ 目录！
除非你显式指定 -mod=vendor，或者设置了 export GOFLAGS=-mod=vendor
  go build -mod=vendor
否则即使你运行过 go mod vendor，Go 默认仍然使用模块缓存（比如 $GOPATH/pkg/mod）来解析依赖

5 构建过程--***那到底 Go 是怎么找到 main 函数的？***
每一个目录是一个 Go 包（一个 package）
每个目录下的 .go 文件应该有相同的 package xxx 声明
***构建的时候是以目录为单位的，而不是以单个文件为单位****

go build ./examples/foo
构建的是 ./examples/foo 目录下的 Go 包（不管你当前在哪）

Go 并不是在全局搜索 main 函数
它只构建你指定的「包」（也就是一个目录），然后：
如果这个包是 package main
并且有 func main()
那就会构建出一个可执行程序

如果你在没有指定参数的情况下运行：
go build
Go 会：
构建当前目录作为一个包
自动把***当前目录（不包括子目录）***下所有以 .go 结尾的源码文件（不包括测试文件）都加入编译
如果当前目录是 package main，就尝试构建可执行文

编译的时候，其实是允许module的循环依赖（不过这个循环依赖不可以是当前工程的，只能是历史的版本的）
比如当前k6->依赖xk6-dashboard->k6的@v1.0.0版本 

但是你要是 k6@v1.0.0->依赖于xk6-dashboard@v2.0.0->k6的@v1.0.0版本  这就是完全不允许的
质上 —— Go module 构建模型必须满足三件事：
✅ 依赖图必须是可解析（Resolvable）
✅ 版本选择必须是确定的（Deterministic）
✅ 构建必须是可终止的（No infinite recursion）


***-mod模式	含义***
mod	默认行为。根据 go.mod 中的版本进行模块解析，必要时更新 go.sum。
readonly	只读取 go.mod 和 go.sum，不允许写入或修改，否则报错。
vendor	忽略 go.mod 解析，使用 vendor/ 目录中的代码。


go run -mod=readonly main.go
Go 会读取 go.mod 和 go.sum 中声明的依赖版本和校验信息，用来下载和验证依赖模块
因为 CI 中的核心目标是验证提交是否干净、依赖是否完整。
如果用了 -mod=mod，哪怕 go.mod 和 go.sum 有问题，***Go 可能会帮你悄悄补全 —— 这在 CI 中不被允许***。
工程依赖了 A，A 依赖了 B。但 A 升级了版本，B 的版本其实也发生了变化（比如换了实现库），


5  golangci-lint的安装与使用
curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v2.1.6
golangci-lint --version
运行 linter 检查项目代码
golangci-lint run

golint 自 2020 年后就不再积极维护了，官方已经明确建议使用更现代的工具，比如：
✅ staticcheck
✅ golangci-lint

golangci-lint 是唯一的、核心的产品，其他没有被广泛推广或不是官方统一命名风格下的工具。golangci 这个名字主要是品牌名或组织名，而不是一个工具家族的统一前缀。


6 go.mod 锁住的是版本，go.sum 锁住的是来源和完整性，
   这两个层次你只控制了一个。

文件	控制内容	类比（快递）
go.mod	依赖列表 + 每个依赖的版本号	我下单了什么、买了哪个牌子
go.sum	每个依赖的来源 + 哈希校验值（完整性）	快递包裹封条的校验码、防篡改条码

***require github.com/evil/dependency v1.0.0***
某天 evil/dependency 的作者在 GitHub 把 v1.0.0 的 tag 改了，偷偷加入恶意代码。
你没动 go.mod，版本号完全一样！
但是：
如果你用 -mod=mod，Go 会拉这个“新 v1.0.0”
发现和 go.sum 里原来的校验值不一样，就会报警或更新
所以——
go.mod 只说：我要用哪一版（v1.0.0）；
go.sum 说：我记得这版的内容是啥，校验过！

7
构建工具生成的 .go 文件触发新的模块下载
项目中用到了像 go generate 生成代码（如 gRPC、protobuf、sqlc），这些 .go 文件在某些情况下会引用新依赖。

你跑完 go generate 后，再执行：
go run -mod=mod main.go
Go 会识别这些 .go 文件中的依赖并补全 go.mod / go.sum，但你自己可能都没注意。

影响：
构建流程顺序不一致导致模块变更
CI/CD 复现失败

这又引申出来一个问题
// +build linux 对于这种，需要提前在平台上补齐，不然肯定出现go.sum不一致了，假如我是windows,开发的时候肯定不会下载这个 
import "github.com/linux/only/pkg

使用 go mod tidy + GOOS=linux 提前补全依赖	预先触发依赖拉取	✅ 推荐
vendor 模式	固定依赖 + 忽略 go.sum	✅ 适合大型项目


8  ***代码结构及共享给其它方***
目录	是否约定俗成	说明
cmd/	✅ 是	多个 CLI 可执行程序的入口目录
internal/	✅ 是	项目私有包，Go 官方强制限制外部访问
examples/	✅ 常见	示例目录，常用于文档和教学
pkg/	✅ 常见	可供外部项目复用的库（你项目中没有）

代码共享的方式：
代码放在 pkg/ 目录下，表示这是对外暴露的公共包，供别的模块导入使用。
Go 的导出规则是“首字母大写”，只有函数名、类型名、变量名等首字母大写，才是包外可见（public）的。

.
├── cmd/            # 每个子目录是一个可执行程序的入口
├── internal/       # 仅供本仓库内部使用的代码（编译器限制外部引用）
├── pkg/            # 可供外部引用的公共代码包
├── api/            # API 接口定义（proto、OpenAPI spec 等）
├── configs/        # 配置文件（yaml、json、toml等）
├── web/            # 前端静态文件、模板
├── scripts/        # 脚本（构建、发布、工具）
├── deployments/    # 部署相关（k8s yaml、docker-compose 等）
├── test/           # 测试辅助代码或集成测试
├── go.mod
├── go.sum
└── README.md


9  ***包名和 import 路径无强制关系，可以不一致***
比如当前项目 go.mod中有一个依赖 github.com/Masterminds/semver/v3 v3.3.1
在luncher.go中有一个使用是这样使用的
"github.com/Masterminds/semver/v3" 
但是在代码中调用的时候是 semver,而这个是包名，所以包名不一定和目录名一致，
使用的时候肯定是包名，导入的时候是目录名
结论： ****使用时的名字是包名（由 package xxx 决定），导入时的路径是源码目录名（用于 Go 找到包位置，含版本后缀）。***

10 ***k6的基本原理***
HTTP/HTTPS 协议的负载测试 —— 绝大部分用例都是 Web 接口的压力和功能测试。
k6 内部自带了一个 JavaScript 引擎（早期是 Goja，纯 Go 实现的 ES5/ES6 引擎，后来增加了部分扩展 API）。
所以当你运行 k6 run test.js 时：
k6 用 Go 编写的核心程序读取你的 test.js
用内置的 Goja 引擎解析和执行 JavaScript
k6 额外提供了 http.get()、sleep() 等特定 API，这些 API 是 Go 语言实现的，然后通过 JS 引擎暴露给脚本用
因此 不需要 Node.js，哪怕你本机完全没有装 Node.js，也可以直接运行 k6


11 ***nocopy的使用，标准库中***
type Mutex struct {
_ noCopy
mu isync.Mutex
}
匿名字段 _ 的好处
用匿名字段 _ 命名，表示这个字段不会占用实际内存空间（空结构体大小为0），不会增加结构体大小。
但是又能触发 go vet 的复制检测。


12  ***解释 interface{} 的作用***
interface{} 叫做 空接口（empty interface），它里面没有任何方法。
因为任何类型都默认实现了「零方法集」的接口（也就是空接口），所以 任何类型的值都可以赋给 interface{} 类型的变量。
其实现在就是 type any interace {}

13  unsafe.Pointer
***unsafe.Pointer 是“通用指针”，只表示“某个内存地址”，但它本身不允许做算术运算，而 uintptr 是整数类型，可以对地址做算术运算***
unsafe.Pointer 是“通用指针”，只表示“某个内存地址”，但它本身不允许做算术运算，而 uintptr 是整数类型，可以对地址做算术运算。

为什么要区分 unsafe.Pointer 和 uintptr？
unsafe.Pointer 表示“内存地址”，但带指针语义。Go 语言的垃圾回收（GC）和内存模型依赖于指针的准确性，编译器和运行时会跟踪指针类型的变量，确保内存安全和 GC 正确回收。
****如果允许对 unsafe.Pointer 做算术运算，会破坏指针语义***
比如对指针做加法、减法、偏移后，指针可能指向“非对象”的地址，GC 无法正确识别。
指针类型的变量必须指向合法的内存对象，否则会出错。
uintptr 是一个普通整数，表示地址的数值：
它没有指针的语义，仅仅是一个数字。
你可以对它做算术运算（加减）来计算偏移。

***但是 uintptr 不被 GC 视为指针，不会阻止所指对象被回收***

*** # (uintptr 是 Go 语言里的无符号整数类型)***
如果你把 uintptr 保存很久或者没有及时转回 unsafe.Pointer，指针指向的对象可能被 GC 回收，导致悬空指针。
Go 官方文档里强调，转换到 uintptr 做算术时，务必立刻转换回 unsafe.Pointer，且不要把 uintptr 类型变量保存下来，否则可能出现安全隐患。

```go
func main() {
	a := []int{1, 2, 4}
	fmt.Printf("数据的长度为:%v\n", len(a))
    //TODO 下面这行  
    // 1 unsafe.Pointer(&a[0]) 这是第一个元素的指针转指针,实现了 具体指针->通用指针
    //2 指针不能运算， 通用指针->uintptr,并做运算 
    // 3 运算的结果uintptr 要尽快转成 "通用指针"  uintptr必须要来转成"通用指针" 
	t := unsafe.Pointer(uintptr(unsafe.Pointer(&a[0])) + unsafe.Sizeof(a[0]))
    //4 通用指针转成具体指针，然后对具体指针进行赋值即可
	*(*int)(t) = 34
}

```

12 为什么 unsafe.Sizeof 返回的是 uintptr 而不是普通的 uint？
func Sizeof(x ArbitraryType) uintptr
我感觉这个ai都没说对，只能说sizeOf本来相当于是指针两减的差值，
能容纳指针并且能做运算的肯定是uintptr了。

13 ***make vs new***
在 Go 里，make 和 new 都是用来分配内存的，但它们的用途、返回值类型、适用对象完全不一样。
***new 只会把分配的内存置为类型的零值，不会帮你把它变成“可用状态”的复杂对象。***
我帮你分成一张对比表，你一眼就能记住：

特性	make	new
用途	初始化内建引用类型（slice、map、chan）	分配任意类型的零值内存
返回类型	返回非指针，是初始化后的对象本身	返回一个指向类型零值的指针
初始化	会做初始化，让 slice、map、chan 可用	只分配内存并置零，不做进一步初始化
适用类型	只能用于 slice、map、chan	可以用于任意类型
零值可用性	返回的值可以直接用（长度、容量等已设定好）	返回的值指向零值，可能还需要进一步初始化

***new 的初始化动作很“懒”：***
数值型 → 0
布尔型 → false
字符串 → ""
指针/引用类型（map、slice、chan、指针）→ nil
而 make 直接帮你把引用类型初始化成可用对象，所以：
只用 new → 你还要自己对引用类型字段 make 一下
用 make → 直接能用，不需要再额外初始

14 ***什么是“零值”***
零值是 Go 语言对某个类型在未显式初始化时所采用的默认值。
语言规范定义了“对于每种类型都有一个零值”，并规定变量在声明但未赋初值时会自动初始化为该类型的零值。零值的含义是“合理的默认值”，而不是内存层面的某种具体比特模式（不要依赖内存比特表示）。

***如何产生零值（声明/构造方式）***
1. var x T → x 被初始化为类型 T 的零值。
2. 局部短变量声明 x := T{}（复合字面量） → 字面量内未指定的字段为零值。
3. new(T) → 返回 *T，指向一个零值的 T。
4. &T{} → 返回 *T，字段为零值（可以在字面量中初始化字段）。
5. make 仅对 slice/map/chan：make 返回已初始化可用的对象，***而不是“零值”***

***接口的零值（nil）
   意义：接口的零值表示“当前没有绑定任何动态类型和值”。***

在内部实现上，接口值包含两个部分：类型信息 + 值。零值接口的这两个部分都是 nil。
nil 接口意味着“没有对象符合这个接口”，常用来表示没有行为对象或错误不存在

